---
layout:     post
title:      09 1 递归快排
subtitle:   hahaha
date:       2019-03-27
author:     orange_heart
header-img: img/2019-7.jpg
catalog: true
tags:
    - 记忆卡片
---

### 试一下

```objc
#include <iostream>
#include <vector>
using namespace std;
int Partition(vector<int> &A,int p,int r){
    int x=A[r];//这里没有采用随机选择一个数，而是选择了直接最后一个值，反正下面都要一个一个递归
    
    int small=p-1;//small记录的是比x小的数有几个
    
    for(int j=p;j<=r-1;++j){
        if(A[j]<=x){
            ++small;
            swap(A[small],A[j]);//发现A[j]是比x小的，赶紧把A[j]往左边放
            
        }
    }
    swap(A[small+1],A[r]);//把A[r]放到正确的位置
    
    return small+1;
}
 
void QuickSort(vector<int> &A,int p,int r){
    if(p<r){
        int q=Partition(A,p,r);//1 先确定了一个位置上应该放的正确的数
        
        QuickSort(A,p,q-1);//2 分别在左右递归的排好每一个位置
        
        QuickSort(A,q+1,r);
    }
}
 
int main(){
    int n;
    cin>>n;
    vector<int> A(n);
    for(int i=0;i<n;++i)
        cin>>A[i];
    QuickSort(A,0,n-1);
    for(int i=0;i<n;++i){
        cout<<A[i];
        if(i!=n-1)
            cout<<" ";
    }
}

```

### 参考

- [play it](https://www.nowcoder.com/questionTerminal/3385982ae71d4a1ca8bf3d03614c0325)
- [来源于此处](https://blog.csdn.net/jw903/article/details/35282035)
- [2种方法](https://www.zybuluo.com/Ggmatch/note/1036346)
- [参考1](https://github.com/zhedahht/CodingInterviewChinese2)
- [参考2](https://github.com/gatieme/CodingInterviews)
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYyMzI5NjA3OSwtNjQyOTE1NzUsMjA0Nj
EyODY2OF19
-->