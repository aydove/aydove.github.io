
---
layout:     post
title:      21 调整数组顺序使奇数位于偶数前面
subtitle:    
date:       2019-04-16
author:     orange_heart
header-img: img/2019-21.jpg
catalog: true
tags:
    - 记忆卡片
---

### 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

最简单的思路就是从头到尾扫描一遍数组，每遇见一个偶数时，就拿出这个数字，并把位于这个数字之后的所有数字往前挪动一位,然后把当前这个偶数放到最后。

这样每次遇到一个偶数就要挪动$O(n)$个数字，因此总的时间复杂度是$O(n^2)$

但是这种方法不仅暴力而且还需要复杂的挪动工作

```objc
class Solution {
public:
    bool isNumeric(const char* str)//注意这里要加一个const，或者应该是把下面的const都去掉，我还没试过
    
{  
//1边界检查

    if(str == nullptr)
        return false;  
//2.1判断整数部分

    bool numeric = scanInteger(&str);

    // 2.2判断小数部分---如果出现'.'，接下来是数字的小数部分
    
    if(*str == '.')
    {
        ++str;
  
        // 下面一行代码用||的原因：
        
        // 1. 小数可以没有整数部分，例如.123等于0.123；
        
        // 2. 小数点后面可以没有数字，例如233.等于233.0；
        
        // 3. 当然小数点前面和后面可以有数字，例如233.666
        
        numeric = scanUnsignedInteger(&str) || numeric;
    }
  
    // 2.3判断指数部分-----如果出现'e'或者'E'，接下来跟着的是数字的指数部分
    
    if(*str == 'e' || *str == 'E')
    {
        ++str;
  
        // 下面一行代码用&&的原因：
        
        // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
        
        // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4
        
        numeric = numeric && scanInteger(&str);
    }  
//3判断是否到结尾

    return numeric && *str == '\0';
}

bool scanUnsignedInteger(const char** str)
{
    const char* before = *str;//注意判断无符号这里会先保存一下开始的位置
    
    while(**str != '\0' && **str >= '0' && **str <= '9')
        ++(*str);
  
    // 当str中存在若干0-9的数字时，返回true
    
    return *str > before;//return这里很有意思~这是一个bool类型的函数哦~
    
}
  
// 整数的格式可以用[+|-]B表示, 其中B为无符号整数

bool scanInteger(const char** str)
{
    if(**str == '+' || **str == '-')
        ++(*str);
    return scanUnsignedInteger(str);
}


};
```
```objc
class Solution {
public:
    void reOrderArray(vector<int> &array)
    {
        if(array.size( ) <= 1)
        {
            return ;
        }
        bool isSwap = false;
        for (int i = 0; i < array.size( ); i++)
        {
            for (int j = array.size() - 1; j > i; j--)
            {
                if (array[j] % 2 == 1 && array[j - 1]%2 == 0) //前偶后奇交换
                {
                    swap(array[j], array[j-1]);
                }
            }
        }


    }
};
```

### 参考

- [参考1](https://github.com/zhedahht/CodingInterviewChinese2)
- [参考2](https://github.com/gatieme/CodingInterviews)
- [play it](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tPage=1)



> Written with [StackEdit](https://stackedit.io/).


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYyNzI2NTQ3MywtMTAwMDg0NDA5MSwtMT
U4MTY1NTU4M119
-->