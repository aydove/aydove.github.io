---
layout:     post
title:      44 把数字翻译成字符串
subtitle:     
date:       2019-04-23
author:     orange_heart
header-img: img/2019-45.jpg
catalog: true
tags:
    - 记忆卡片
---

###  把数字翻译成字符串

这应该是斐波那契，还是动态规划？剪绳子？反正我只能看明白分段递推函数

----------------
一条包含字母 A-Z 的消息通过以下方式进行了编码：[here](https://blog.csdn.net/yuanliang861/article/details/83536407)
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2:
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

**说明**：
本题其实不难，只不过边界情况比较多，自己做了好长时间，始终是没有考虑全。

一开始就直接想到了info[i]=info[i-1]+info[i-2]，以及少数边界情况，可惜始终没有作对。看了一下别人的解答，把采用下面的这种方式，不去一一罗列每一种情况，将是否加info[i-1]或者info[i-2]分开。这就好很多了。

----------------

1.  动态规划：`info[i]=info[i-1]+info[i-2]`
2.  合法性判断：若当前解码1位i，则i-1位不可为0；若当前解码2位，则`10<=substr(i-2,i-1)<=26`

---------------------

下面这4步**与代码不符合**，但是我喜欢这种一步一步的分析，作为理解动态规划？递推函数？算是一个好的途径，而且也说明了如果初始化f[0]：
（一）状态

f[i]表示前 i 个字符组成的子串，有多少种解码方法
（二）转移方程

若 s[i] != '0' , f[i] = f[i - 1] （单字符编码）
若 s[i - 1, i] 在 10 到 26 之间 , f[i] += f[i - 2] （双字符编码）
（三）初始化

f[0] = 1, 举例来说 "12" ，f[2] = f[1] + f[0] = 1 + 1 = 2
f[1] = s.charAt(0) == '0' ? 0 : 1;
（四）结果

f[n]


```objk
class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        if(s.empty())
            return 0;
        if(s[0]=='0')
            return 0;
        vector<int> info(n+1,0);
        info[0]=1;
        info[1]=1;
        for(int i=2;i<n+1;i++)
        {
            if(s[i-1]!='0')
                info[i]+=info[i-1];
            if(s.substr(i-2,2)<="26"&&s.substr(i-2,2)>="10")
                info[i]+=info[i-2];
        }
        return info[n];
        
    }
};
```

 - 先特殊情况特殊返回
 - 建立一个数组存放每一步的结果
 - 初始化几个基础积木值
 - 搭积木直到n（注意2个if条件的判断）



 - s.substr(i-2,2)<="26"注意双引号、substr函数
 - s.empty()
 - if(s[i-1]!='0')
 - 搞不懂为什么vector<int> info(n+1,0);这里为什么是n+1？？？？🧐🧐🧐🧐🧐

### 参考

- [参考1](https://github.com/zhedahht/CodingInterviewChinese2)
- [参考2](https://github.com/gatieme/CodingInterviews)
- [play it](https://leetcode-cn.com/problems/decode-ways/)


> Written with [StackEdit](https://stackedit.io/).

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3OTYzODM2MjYsNDcwMTA4ODM4LC0xOT
IxNjQ1NjcsNjUwODM4NTM4LC0xNDYyMjU2NDc0LDkyODU0NjE2
XX0=
-->